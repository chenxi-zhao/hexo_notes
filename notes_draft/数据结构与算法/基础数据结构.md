### 栈与队列
栈和队列都是动态集合，栈LIFO，队列先进后出FIFO

#### 双端队列
即在队列两端都可以insert和remove：insertLeft、insertRight，removeLeft、removeRight
含有栈和队列的功能，如去掉insertLeft、removeLeft，那就跟栈一样了；如去掉insertLeft、removeRight，那就跟队列一样了
一般使用频率较低，时间复杂度 O(1)

#### 优先级队列
内部维护一个按优先级排序的序列。插入时需要比较查找插入的位置(插入排序)，时间复杂度O(N)，删除O(1)

#### 两个队列实现一个栈
插入操作在stack1中进行，删除操作在stack2中进行，如果stack2为空，则将stack1中的所有元素转移到stack2中。

![](http://images.cnitblog.com/blog/408927/201303/01213849-465c3235203447c1960257f78c95a260.png)

#### 两个栈实现一个队列
1. 元素集中存放在一个栈中，但不是指定(q1 或 q2)。
2. 定义两个指针：pushtmp:指向专门进栈的队列； tmp：指向临时作为中转站的另一个栈
3. 入栈：直接入pushtmp所指队列即可
4. 出栈：把pushtmp队列除最后一个元素外全部转移到队列tmp中,然后把最后一个元素出队列,然后交换指针

![](http://images.cnitblog.com/blog/408927/201303/02121843-6e98f7733ed34e06ad584ac91dde3404.x-png)
![](http://images.cnitblog.com/blog/408927/201303/02122023-18d8a2abe3b74cb6839c6b08d8c43b61.x-png)

### 链表
链表（Linked List）各对象按照线性顺序排列，链表顺序由对象中的指针所决定
>ps. 链表有很多种，可以是单双向，也可以是有无序，还可能是循环的，单链表没有prev节点

**`双向链表`**：每个元素有prev和next两个指针，没有前驱则是head节点，没有后继为tail节点

**`循环链表`**：表头prev指向表尾，表尾next指向表头

#### 时间复杂度
- 搜索一般是O(n)
- 无序链表插入为O(1),有序链表插入寻找位置最差为O(n)
- 按关键字删除先搜索，所以为O(n)，如果直接给节点元素指针，则为O(1)

#### 哨兵
添加一个辅助对象，prev指向表尾，next指向表头，将双向链表变成了一个**又哨兵的双向循环链表**。
哨兵一般用作简化代码，忽略表头和表尾的边界条件处理

### 散列表
#### 直接寻址表
数组可以进行直接寻址，所以能在O(1)时间内访问任意元素，数组的下标就是寻址的关键字

#### 散列表
直接寻址表可能会非常浪费内存，所以有了散列表。

散列表利用散列函数由关键字计算出存储的槽的位置，然后存储数据，但是不同关键字可能计算出相同的槽位，所以有了冲突

#### 散列冲突
1. 链接法解决冲突
将散列到同一个槽中的所有元素存储到链表中

#### 散列函数

除法散列法
h(k) = k mod m
m是散列表槽位数量

乘法散列法
![](http://hi.csdn.net/attachment/201103/3/9610_129911890437V8.png)

全域散列法
随机选择散列函数，使之独立于要存储的关键字。

























