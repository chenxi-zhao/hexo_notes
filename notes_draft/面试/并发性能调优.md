#### 有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?
A. 服务器访问数据库查询手机号，手机号添加索引，算法缓存手机号索引（缓存设置时效以及），分布式系统，负载均衡

#### 高并发情况下，我们系统是如何支撑大量的请求的
A. 分布式系统，集群优化，负载均衡，异步消息，异步执行，分布式缓存

#### 集群如何同步会话状态
A. 利用数据库同步session，利用cookie同步session，利用memcache同步session
http://blog.chinaunix.net/uid-20642150-id-3184231.html

#### 负载均衡的原理
>http重定向、DNS负载均衡、反向代理负载均衡、IP负载均衡(LVS-NAT)、直接路由(LVS-DR)

负载平衡（Load balancing）是一种计算机网络技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。
![][https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1]

#### 如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）
- 数据库结构的设计
数据行的长度不要超过8020字节，超过这个长度的话在物理页中这条数据会占用两行从而造成存储碎片，降低查询效率。能够用数字类型的字段尽量选择数字类型而不用字符串类型。变化不大的字段可以选择CHAR，对于评论等长度变化大的字段可以选择VARCHAR。字段的长度在最大限度的满足可能的需要的前提下，应该尽可能的设得短一些，这样可以提高查询的效率，而且在建立索引的时候也可以减少资源的消耗。

- 查询的优化
保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如SELECT * FROM T1语句，要用到几列就选择几列；在可能的情况下尽量限制尽量结果集行数（分页，top等）；必要的字段建立索引；优化查询最重要的就是，尽量使语句符合查询优化器的规则避免全表扫描而使用索引查询。

>1. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描(设0)
2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。
3. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描
4. in（？） 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。
5. 尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。
6. 必要时强制查询优化器使用某个索引，如在 where 子句中使用参数，也会导致全表扫描。（select id from t with(index(索引名)) where num=@num）
7. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。(任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。)
8. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
9. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
10. 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。
11. 很多时候用 exists是一个好的选择,因为不会产生大量锁定的表扫描或是索引扫描。
12. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
13. 避免频繁创建和删除临时表，以减少系统表资源的消耗。
14. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。
15. 在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替createtable，避免造成大量log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。
16. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
17. 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。
18. 尽量避免大事务操作，提高系统并发能力。
19. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
20. 避免使用不兼容的数据类型。例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。
21. 充分利用连接条件，在某种情况下，两个表之间可能不只一个的连接条件，这时在WHERE子句中将连接条件完整的写上，有可能大大提高查询速度。
22. 使用视图加速查询，把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。
23. 能用DISTINCT的就不用GROUP BY
24. 能用UNION ALL就不要用UNION
35. 尽量不要用SELECT INTO语句，SELECT INOT 语句会导致表锁定，阻止其他用户访问该表。

- 算法的优化
尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。封装存储过程

- 建立高效的索引
创建索引一般有以下两个目的：维护被索引列的唯一性和提供快速访问表中数据的策略。大型数据库有两种索引即簇索引和非簇索引，一个没有簇索引的表是按堆结构存储数据，所有的数据均添加在表的尾部，而建立了簇索引的表，其数据在物理上会按照簇索引键的顺序存储，一个表只允许有一个簇索引，因此，根据B树结构，可以理解添加任何一种索引均能提高按索引列查询的速度，但会降低插入、更新、删除操作的性能，尤其是当填充因子（Fill Factor）较大时。所以对索引较多的表进行频繁的插入、更新、删除操作，建表和索引时因设置较小的填充因子，以便在各数据页中留下较多的自由空间，减少页分割及重新组织的工作。
| 动作描述 | 使用聚集索引 | 使用非聚集索引 |
| --- | --- | --- |
| 列经常被分组排序 | 应 | 应 |
| 返回某范围内的数据 | 应 | 不应 |
| 一个或极少不同值 |不应 | 不应 |
| 小数目的不同值 |应 | 不应 |
| 大数目的不同值 |不应 | 应 |
| 频繁更新的列 |不应 | 应 |
| 外键列 |应 | 应 |
| 主键列 |应 | 应 |
| 频繁修改索引列 |不应 | 应 |

>聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。聚集索引对于那些经常要搜索范围值的列特别有效。当索引值唯一时，使用聚集索引查找特定的行也很有效率。
非聚集索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。

##### 优化法则
| 优化法则 | 性能提升效果 | 优化成本 | 具体实现途径 |
| --- | --- | --- | --- |
| 减少数据访问 | 1~1000 | 低 | 索引(不等操作、列操作、前导模糊查询、null、数据类型不同、等式右边数据确定) |
| 返回更少数据 | 1~100 | 低 | 分页、只返回需要的字段 |
| 减少交互次数 | 1~20 | 低 | batch DML、In List（in 数量不宜过大）、Fetch Size、存储过程、优化业务逻辑、ResultSet |
| 减少服务器CPU开销 | 1~5 | 低 | 绑定变量、合理使用排序、减少比较操作、大量复杂运算在客户端处理 |
| 利用更多资源 | @~10 | 高 | 客户端多进程并行访问、数据库并行处理 |

>当一条SQL发送给数据库服务器后，系统首先会将SQL字符串进行hash运算，得到hash值后再从服务器内存里的SQL缓存区中进行检索，如果 有相同的SQL字符，并且确认是同一逻辑的SQL语句，则从共享池缓存中取出SQL对应的执行计划，根据执行计划读取数据并返回结果给客户端。
如果在共享池中未发现相同的SQL则根据SQL逻辑生成一条新的执行计划并保存在SQL缓存区中，然后根据执行计划读取数据并返回结果给客户端。

#### 如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题。
首先要了解高并发的的瓶颈在哪里？
1、可能是服务器网络带宽不够（增加网络带宽，DNS域名解析分发多台服务器。）
2、可能web线程连接数不够（负载均衡，前置代理服务器nginx、apache等等）
3、可能数据库连接查询上不去。（数据库查询优化，读写分离，分表等等）
根据不同的情况，解决思路也不同。

最后复制一些在高并发下面需要常常需要处理的内容:
- 尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。
- 用jprofiler等工具找出性能瓶颈，减少额外的开销。
- 优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。
- 优化数据库结构，多做索引，提高查询效率。
- 统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要实时进行统计的功能。
- 能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。
- 解决以上问题后，使用服务器集群来解决单台的瓶颈问题。
- 前端页面优化，HTML、js压缩等
- 图片服务器分离


#### 假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。
同上、可添加分析java堆栈数据

8. 如何查找造成性能瓶颈出现的位置，是哪个位置照成性能瓶颈。
通过监控服务器负载和IO查找问题，通过源代码以及堆栈分析查找程序问题，分析数据库慢日志优化数据库问题，优化图片、资源问题

9. 你的项目中使用过缓存机制吗？
