1. Java的内存模型以及GC算法
- Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量”和“从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。
- 引用计数法、标记清除法、标记压缩法、复制算法

2. jvm性能调优都做了什么
控制GC的行为(GC算法、垃圾收集器，时机),控制JVM堆栈大小，控制JVM线程的内存分配。

3. 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明
http://www.cnblogs.com/wangwanchao/p/6383441.html

4. 介绍GC 和GC Root不正常引用。
![内存泄露][http://blog.csdn.net/anxpp/article/details/51325838]

5. 自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展

6. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析

7. 数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）,老年代中数组的访问方式

>1，数组访问方式和对象访问一样
2，至于多大放入老年代，有参数可以配置，正常是如果年轻化放不下，直到放老年代 3，一般的判断对象可回收有2种算法，一个引用计数算法，java是可达性分析算法，解决环的问题

9. GC算法，永久代对象如何GC，GC有环怎么处理
hotspot的方法区存放在永久代中，因此方法区被人们称为永久代。永久代的垃圾回收主要包括类型的卸载和废弃常量池的回收。当没有对象引用一个常量的时候，该常量即可以被回收。而类型的卸载更加复杂。必须满足一下三点，该类型的所有实例都被回收了，该类型的ClassLoader被回收了，该类型对应的java.lang.Class没有在任何地方被引用，在任何地方都无法通过反射来实例化一个对象

10. 谁会被GC ，什么时候GC
不可达对象，新生区满了、老年代满了

11. 如果想不被 GC 怎么办
可以先说那些对象可以被GC,然后说java对象会不会回收，决定于是否还被引用，不被引用了就有可能被GC回收，一直被引用着就不会被回收.


12. 如果想在 GC 中生存 1 次怎么办
生存一次，释放掉对象的引用，但是在对象的finalize方法中重新建立引用，但是有一此方法只会被调用一次，所以能在GC中生存 一次

13. jdk、jre、jvm关系
![](http://www.hollischuang.com/wp-content/uploads/2015/04/2932682015-300x184.gif)
