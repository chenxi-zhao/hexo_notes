1. Java的内存模型以及GC算法
- Java内存模型描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互。它描述了“程序中的变量”和“从内存或者寄存器获取或存储它们的底层细节”之间的关系。Java内存模型通过使用各种各样的硬件和编译器的优化来正确实现以上事情。
- 引用计数法、标记清除法、标记压缩法、复制算法

2. jvm性能调优都做了什么
控制GC的行为(GC算法、垃圾收集器，时机),控制JVM堆栈大小，控制JVM线程的内存分配。

3. 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明
http://www.cnblogs.com/wangwanchao/p/6383441.html

4. 介绍GC 和GC Root不正常引用。
![内存泄露][http://blog.csdn.net/anxpp/article/details/51325838]

5. 自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展

6. jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析

7. 数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）,老年代中数组的访问方式

>1，数组访问方式和对象访问一样
2，至于多大放入老年代，有参数可以配置，正常是如果年轻化放不下，直到放老年代 3，一般的判断对象可回收有2种算法，一个引用计数算法，java是可达性分析算法，解决环的问题

9. GC算法，永久代对象如何GC，GC有环怎么处理
hotspot的方法区存放在永久代中，因此方法区被人们称为永久代。永久代的垃圾回收主要包括类型的卸载和废弃常量池的回收。当没有对象引用一个常量的时候，该常量即可以被回收。而类型的卸载更加复杂。必须满足一下三点，该类型的所有实例都被回收了，该类型的ClassLoader被回收了，该类型对应的java.lang.Class没有在任何地方被引用，在任何地方都无法通过反射来实例化一个对象

10. 谁会被GC ，什么时候GC
不可达对象，新生区满了、老年代满了

11. 如果想不被 GC 怎么办
可以先说那些对象可以被GC,然后说java对象会不会回收，决定于是否还被引用，不被引用了就有可能被GC回收，一直被引用着就不会被回收.


12. 如果想在 GC 中生存 1 次怎么办
生存一次，释放掉对象的引用，但是在对象的finalize方法中重新建立引用，但是有一此方法只会被调用一次，所以能在GC中生存 一次

13. jdk、jre、jvm关系
![](http://www.hollischuang.com/wp-content/uploads/2015/04/2932682015-300x184.gif)

14. 元空间和永久代
- PermGen（永久代）
绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。

- Metaspace（元空间）
其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，`譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap`。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

15. JVM逃逸分析及优化策略
首先说明一下什么是逃逸，当一个对象的指针被多个方法或线程引用时就称这个对象发生了逃逸。

通俗的讲就是在一个方法内部生产的对象，除了在方法内部使用以外，还被方法外的变量所引用，发生逃逸会引起方法执行完成以后，方法中创建的对象无法被GC回收，正常情况下，方法调用结束后，方法中创建的对象将可进行回收。`jdk1.8中逃逸分析默认开启`。

逃逸可分为2种情况，方法逃逸与线程逃逸
- 方法逃逸：当一个对象在方法中定义之后，作为参数传递到其它方法中；
- 线程逃逸：如类变量或实例变量，可能被其它线程访问到；

