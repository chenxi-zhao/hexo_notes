#### MySql的存储引擎的不同
![](http://static.tmaczhao.cn/images/638e7697069c9a17a1e78d6b21aacc77.jpg)

#### 单个索引、联合索引、主键索引
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。

普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。

主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。
索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。

主键还存在复合主键（联合主键）
复合主键就是指你表的主键含有一个以上的字段组成 。

#### Mysql怎分表后如果想按条件分页查询怎么办(如果不是按分表字段么分表，以及来查询的话，几乎效率低下，无解)
MySQL处理大规模业务数据的方案一般都是分库分表.

最开始一般都选择垂直拆分.
比如电商网站,可能按照家电,图书,母婴等商品分类进行拆分.
这样做的好处是拆分简单,并且没有破坏数据库事务.

但是随着业务的增长,比如图书分类的订单数据表已经到达了10个T的规模.
就需要考虑做水平拆分了.把逻辑上一个表的数据,分别存放到不同的数据库服务器.
水平拆分的好处是
    多个数据库服务器分担CPU,内存,网络带宽的压力.
    多个数据库服务器分担备份、恢复的压力.
缺点是
    破坏了原生的数据库事务.如果使用分布式事务,则会拖累数据库性能.
    增加了运维管理的负担.原来管一台服务器就行了,现在得管一堆服务器.

水平拆分的三种主要方式
1.Hash拆分.比如按照 userId mod 64.将数据分布在64个服务器上
2.范围拆分.比如每台服务器计划存放一个亿的数据,先将数据写入服务器A.一旦服务器A写满,则将数据写入服务器B,以此类推.
这种方式的好处是扩展方便.数据在各个服务器上分布均匀.
3.路由表.自定义分布方式.

![][http://blog.itpub.net/29254281/viewspace-1819422/]


#### 分表之后想让一个id多个表是自增的，效率实现
- 数据库自增ID
![](http://static.tmaczhao.cn/images/032cc46be023c0ce2bf6cb7227475d08.jpg!md)

- 使用Redis自增
    使用两个Redis实例,一个分发奇数ID,一个分发偶数ID
    任何一个Redis损坏,都可以切换到另外一个Redis实例.

- 使用程序模拟序列
    初始化先从数据库拿到一段ID,然后分发。
    一旦ID耗尽,再从数据库获取一段ID。
    可以启动多个ID生成服务,避免单点故障.
    ID生成服务本身应该串行化,避免锁竞争.

#### MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离
- 什么是mysql主从同步？
    当master(主)库的数据发生变化的时候，变化会实时的同步到slave(从)库。
- 主从同步有什么好处？
    1. 水平扩展数据库的负载能力。
    2. 容错，高可用。Failover(失败切换)/High Availability
    3. 数据备份。

- 主从同步的原理是什么？
在master机器上，主从同步事件会被写到特殊的log文件中(binary-log);
在slave机器上，slave读取主从同步事件，并根据读取的事件变化，在slave库上做相应的更改。

主从同步事件有3种形式:statement、row、mixed。
    - statement：会将对数据库操作的sql语句写入到binlog中。
    - row：会将每一条数据的变化写入到binlog中。
    - mixed：statement与row的混合。Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。

1、在master机器上的操作
当master上的数据发生改变的时候，该事件(insert、update、delete)变化会按照顺序写入到binlog中。
**binlog dump线程**
当slave连接到master的时候，master机器会为slave开启binlog dump线程。当master 的 binlog发生变化的时候，binlog dump线程会通知slave，并将相应的binlog内容发送给slave。

2、在slave机器上的操作
当主从同步开启的时候，slave上会创建2个线程。
- I/O线程。该线程连接到master机器，master机器上的binlog dump线程会将binlog的内容发送给该I/O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log。
- SQL线程。该线程读取I/O线程写入的relay log。并且根据relay log的内容对slave数据库做相应的操作。


#### 写SQL语句。。。

#### 索引的数据结构，B+树

#### 事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题
事务就是一组原子性的SQL查询。(ACID, 原子性、一致性、隔离性、持久型)
- 原子性：系统操作必须具有原子性，要么全部操作，要么不操作
- 一致性：一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。如果出发辅助操作（如级联、触发器），这些操作也必须成功。多节点必须传播到所有节点，如果是主从异步更新，那就打破了一致性，保持“最终一致性”。
事务是并发多个，系统也必须如同串行事务一样操作。
- 隔离性：事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。
- 持久性：一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中。如果我们的系统突然受到系统崩溃或断电，那么所有未完成已提交的事务可能会重演。

#### 数据库的锁：行锁，表锁；乐观锁，悲观锁
![](http://static.tmaczhao.cn/images/9dc2ab685e4a176796f87ad8eb9f61e2.jpg)

![](http://static.tmaczhao.cn/images/91fe82fb7544d66cb728fec0afa88008.jpg!md)
![](http://static.tmaczhao.cn/images/935e4916621ceb45b59e3493cffb6fc5.jpg)

>InnoDB行锁实现方式
InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
`在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。`


#### 数据库事务的几种粒度；

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 读锁 |
| --- | --- | --- | --- | --- |
| READ UNCOMMITTED | YES | YES | YES | NO |
| READ COMMITTED | NO | YES | YES | NO |
| REPEATABLE READ | NO | NO | YES | NO |
| SEAIALIZABLE | NO | NO | NO | YES |


#### 关系型和非关系型数据库区别
- 非关系型数据库的优势：
1. 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
2. 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

- 关系型数据库的优势：
1. 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
2. 事务支持使得对于安全性能很高的数据访问要求得以实现。

对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
