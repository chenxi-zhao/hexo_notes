### Linux
#### uptime
**uptime**命令能够打印系统总共运行了多长时间和系统的平均负载。
```
15:31:30 //系统当前时间
up 127 days,  3:00 //主机已运行时间,时间越大，说明你的机器越稳定。
1 user //用户连接数，是总连接数而不是用户数
load average: 0.00, 0.00, 0.00 // 系统平均负载，统计最近1，5，15分钟的系统平均负载
```

#### top
top命令可以实时动态地查看系统的整体运行情况，像linux的任务管理器。

```
-b：以批处理模式操作；
-c：显示完整的治命令；
-d：屏幕刷新间隔时间；
-I：忽略失效过程；
-s：保密模式；
-S：累积模式；
-i<时间>：设置间隔时间；
-u<用户名>：指定用户名；
-p<进程号>：指定进程；
-n<次数>：循环显示的次数。
```

在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了-s选项， 其中一些命令可能会被屏蔽。
```
h：显示帮助画面，给出一些简短的命令总结说明；
k：终止一个进程；
i：忽略闲置和僵死进程，这是一个开关式命令；
q：退出程序；
r：重新安排一个进程的优先级别；
S：切换到累计模式；
s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s； f或者F：从当前显示中添加或者删除项目；
o或者O：改变显示项目的顺序；
l：切换显示平均负载和启动时间信息；
m：切换显示内存信息；
t：切换显示进程和CPU状态信息；
c：切换显示命令名称和完整命令行；
M：根据驻留内存大小进行排序；
P：根据CPU使用百分比大小进行排序；
T：根据时间/累计时间进行排序；
w：将当前设置写入~/.toprc文件中。
```

#### vmstat
可以统计系统的CPU，内存，swap，io等情况
```
-a：显示活动内页；
-f：显示启动后创建的进程总数；
-m：显示slab信息；
-n：头信息仅显示一次；
-s：以表格方式显示事件计数器和内存状态；
-d：报告磁盘状态；
-p：显示指定的硬盘分区状态；
-S：输出信息的单位。

参数 事件间隔：状态信息刷新的时间间隔； 次数：显示报告的次数。
```

##### 实例
```
vmstat 3
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r b  swpd  free   buff    cache   si  so    bi     bo  in   cs    us sy id wa st
 0 0  320  42188  167332  1534368  0    0    4      7   1     0    0  0  99  0 0
 0 0  320  42188  167332  1534392  0    0    0      0   1002 39    0  0  100 0 0
 0 0  320  42188  167336  1534392  0    0    0      19  1002 44    0  0  100 0 0
 0 0  320  42188  167336  1534392  0    0    0      0   1002 41    0  0  100 0 0
 0 0  320  42188  167336  1534392  0    0    0      0   1002 41    0  0  100 0 0
```

##### 字段说明：
###### Procs（进程）
- r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1）
- b: 等待IO的进程数量。

###### Memory（内存）
- swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。
- free: 空闲物理内存大小。
- buff: 用作缓冲的内存大小。
- cache: 缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。

###### Swap
- si: 每秒从交换区写到内存的大小，由磁盘调入内存。
- so: 每秒写入交换区的内存大小，由内存调入磁盘。

>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。

###### IO（现在的Linux版本块的大小为1kb）
- bi: 每秒读取的块数
- bo: 每秒写入的块数 注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。

###### system（系统）
- in: 每秒中断数，包括时钟中断。
- cs: 每秒上下文切换数。

>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。

###### CPU（以百分比表示）
- us: 用户进程执行时间百分比（usertime）us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。
- sy: 内核系统进程执行时间百分比（systemtime）sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。
- wa: IO等待时间百分比 wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。
- id: 空闲时间百分比

#### pidstat


### Windows
#### window task explorer
#### perfmon
#### process explorer
#### pslist

### Java
#### jps  列出java进程，类似于ps命令
#### jinfo 查询设置jvm参数值
#### jmap  生成Java应用程序的堆快照和对象的统计信息
#### jstack  打印线程dump
#### jconsole 图形化监控工具
#### jvisualvm
