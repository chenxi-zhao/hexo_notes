#### Topic 1.JVM运行时数据区里有什么？
![](http://static.tmaczhao.cn/images/be82a705c27e8b861ad4013acc6946d9.jpg)

#### Topic 2. 虚拟机栈是什么？虚拟机栈里有什么？
![](http://static.tmaczhao.cn/images/2edef987bd4f62dc853346f45eb1a8f3.jpg)

#### Topic 3. 栈帧是什么？栈帧里有什么？
![](http://static.tmaczhao.cn/images/2f9db17367665093a4af9e8fe7635f1b.jpg)

#### Topic 4. 方法区是什么？方法区里有什么？
![](http://static.tmaczhao.cn/images/24f8bca34e9b698de16a0b13b2d40af0.jpg)


### 对象创建
Java是一门面向对象的语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（克隆、反序列化）就是一个new关键字而已，但是虚拟机层面上却不是如此。看一下在虚拟机层面上创建对象的步骤：

1. 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那么必须先执行类的初始化过程。

2. 类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完成后便可以完全确定，为对象分配空间无非就是从Java堆中划分出一块确定大小的内存而已。这个地方会有两个问题：

	+ 如果内存是规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。

	+ 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。如果垃圾收集器选择的是CMS这种基于标记-清除算法的，虚拟机采用这种分配方式。

另外一个问题及时保证new对象时候的线程安全性。因为可能出现虚拟机正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。虚拟机采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题。

3. 内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

4. 对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。

5. 执行\<init\>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

以上这部分内容，如果有下载OpenJDK的源代码的话，可以通过参考hotspot/src/share/vm/interpreter/bytecodeInterpreter.cpp文件，从1939行开始。1939行的代码是CASE(_new):{...}，意思是当代码中遇见new这个关键字，虚拟机做的事情。实际虚拟机可能并不是执行的这段代码，但是通过这段代码来了解new对象的时候虚拟机的运作过程基本上是没问题的。